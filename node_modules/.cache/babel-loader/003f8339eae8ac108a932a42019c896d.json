{"ast":null,"code":"var D = Object.defineProperty;\nvar x = Object.getOwnPropertySymbols;\nvar F = Object.prototype.hasOwnProperty,\n  q = Object.prototype.propertyIsEnumerable;\nvar S = (s, t, i) => t in s ? D(s, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: i\n  }) : s[t] = i,\n  c = (s, t) => {\n    for (var i in t || (t = {})) F.call(t, i) && S(s, i, t[i]);\n    if (x) for (var i of x(t)) q.call(t, i) && S(s, i, t[i]);\n    return s;\n  };\nvar d = (s, t) => () => (s && (t = s(s = 0)), t);\nvar L = (s, t) => () => (t || s((t = {\n  exports: {}\n}).exports, t), t.exports);\nfunction a(s, t) {\n  return Math.floor(Math.random() * (t - s) + 1) + s;\n}\nfunction l(s) {\n  return s[Math.floor(Math.random() * s.length)];\n}\nfunction m(s) {\n  return Math.sin(s * (Math.PI / 180));\n}\nfunction y(s) {\n  return Math.cos(s * (Math.PI / 180));\n}\nvar g = d(() => {});\nvar p,\n  w,\n  C = d(() => {\n    g();\n    p = class {\n      constructor(t, i) {\n        this.stars = [];\n        this.config = {\n          quantity: 100,\n          direction: 100,\n          speed: [.5, .8],\n          backgroundColor: \"#ccc\",\n          starColor: \"white\",\n          starSize: [0, 3]\n        };\n        this.overflowSize = 10;\n        this.canvas = null;\n        this.ctx = null;\n        this.config = c(c({}, this.config), i), this.canvas = t, this.ctx = t.getContext(\"2d\");\n      }\n      draw() {\n        for (let t = 0; t < this.stars.length; t++) {\n          let i = this.stars[t];\n          this.ctx.beginPath(), this.ctx.fillStyle = this.config.starColor, this.ctx.save(), this.ctx.globalAlpha = i.opacity, this.ctx.arc(i.x, i.y, i.size, 0, Math.PI * 2), this.ctx.fill(), this.ctx.restore(), this.ctx.closePath();\n        }\n      }\n      update() {\n        let t = m(this.config.direction),\n          i = y(this.config.direction);\n        for (let r = 0; r < this.stars.length; r++) {\n          let h = this.stars[r];\n          if (h.x += t * h.speed, h.y += i * h.speed, h.x > this.canvas.width + this.overflowSize || h.x < 0 - this.overflowSize || h.y > this.canvas.height + this.overflowSize || h.y < 0 - this.overflowSize) {\n            this.stars.splice(r, 1);\n            let o, n, e;\n            i == -1 || i == 1 ? (e = 0, o = a(e, this.canvas.width), n = i == 1 ? 0 : this.canvas.height) : t == -1 || t == 1 ? (e = t == 1 ? 0 : this.canvas.width, o = e + this.overflowSize * -t, n = a(0, this.canvas.height)) : t > 0 && i > 0 ? (e = -this.overflowSize, o = l([e, a(e, this.canvas.width - this.overflowSize)]), n = o == e ? a(e, this.canvas.height - this.overflowSize) : -this.overflowSize) : t < 0 && i > 0 ? (e = -this.canvas.width + this.overflowSize, o = l([e, a(e, 0 + this.overflowSize)]), n = o == e ? a(e, 0 - this.canvas.height + this.overflowSize) : -this.overflowSize) : t < 0 && i < 0 ? (e = this.canvas.width + this.overflowSize, o = l([e, a(e, 0 + this.overflowSize)]), n = o == e ? a(e, 0 + this.overflowSize) : this.canvas.height + this.overflowSize) : t > 0 && i < 0 && (e = -this.overflowSize, o = l([e, a(e, this.canvas.width - this.overflowSize)]), n = o == e ? a(e, this.canvas.height - this.overflowSize) : this.canvas.height + this.overflowSize);\n            let A = {\n              x: o,\n              y: n\n            };\n            this.generate(1, A);\n          }\n        }\n      }\n      generate(t) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        if (i) {\n          let {\n              x: r,\n              y: h\n            } = i,\n            o = {\n              x: r,\n              y: h,\n              size: this.randomSize(),\n              opacity: this.randomOpacity(),\n              speed: this.randomSpeed()\n            };\n          return this.stars.push(o);\n        }\n        for (let r = 0; r < t; r++) {\n          let h = a(0, this.canvas.width),\n            o = a(0, this.canvas.height);\n          this.stars.push({\n            x: h,\n            y: o,\n            size: this.randomSize(),\n            opacity: this.randomOpacity(),\n            speed: this.randomSpeed()\n          });\n        }\n      }\n      randomSize() {\n        return typeof this.config.starSize == \"object\" ? a(this.config.starSize[0], this.config.starSize[1]) : this.config.starSize;\n      }\n      randomOpacity() {\n        let t = this.config.randomOpacity;\n        return typeof t == \"boolean\" ? t ? (t ? Math.random() : 1).toFixed(2) : 1 : (Math.random() * (t[1] - t[0]) + t[0]).toFixed(2);\n      }\n      randomSpeed() {\n        let t = this.config.speed;\n        return Array.isArray(t), Math.random() * (t[1] - t[0]) + t[0];\n      }\n    }, w = p;\n  });\nvar v,\n  b,\n  z = d(() => {\n    g();\n    v = class {\n      constructor(t, i) {\n        this.stars = [];\n        this.config = {\n          type: \"line\",\n          slope: {\n            x: 1,\n            y: 1\n          },\n          frequency: 10,\n          speed: 2,\n          starSize: 100,\n          starColor: [\"#fb00ff\", \"#00dde0\"],\n          spread: 1,\n          directionY: -1,\n          directionX: 1,\n          distanceX: .1,\n          quantity: 200\n        };\n        this.direction = 225;\n        this.canvas = null;\n        this.ctx = null;\n        this.config = c(c({}, this.config), i), this.canvas = t, this.ctx = t.getContext(\"2d\");\n      }\n      draw() {\n        this.ctx.strokeStyle = \"white\", this.stars.forEach(t => {\n          let i;\n          Array.isArray(this.config.starColor) ? (i = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height), this.config.starColor.forEach((r, h) => i.addColorStop(h / this.config.starColor.length, r))) : i = this.config.starColor, this.ctx.save(), this.ctx.strokeStyle = i, this.ctx.beginPath(), this.ctx.moveTo(t.start.x, t.start.y), this.ctx.setLineDash([this.config.starSize, t.startPoint * this.config.frequency]), this.ctx.lineDashOffset = this.config.directionY * (t.progress + t.length), this.ctx.quadraticCurveTo(t.curve.x, t.curve.y, t.end.x, t.end.y), this.ctx.stroke(), this.ctx.closePath(), this.ctx.restore();\n        });\n      }\n      update() {\n        this.stars.map((t, i) => {\n          t.progress += t.speed;\n        });\n      }\n      generate() {\n        for (let t = 0; t < this.config.quantity; t++) {\n          let i = a(-20, this.canvas.width),\n            r = i <= 0 ? a(0, this.canvas.height) : 0,\n            h = 100,\n            o = i + (this.canvas.width * this.config.distanceX + this.config.spread * i * this.config.directionX),\n            n = o - i,\n            e = this.canvas.height;\n          this.stars.push({\n            x: i,\n            y: r,\n            length: e,\n            height: h,\n            progress: 0,\n            speed: this.config.speed + Math.random() / 5,\n            lineDash: a(50, 100),\n            filter: {\n              opacity: l([a(20, 100) + \"%\", !1])\n            },\n            start: {\n              x: i,\n              y: r\n            },\n            curve: {\n              x: i + n * this.config.slope.x,\n              y: r + this.canvas.height * this.config.slope.y\n            },\n            startPoint: a(10, 100),\n            end: {\n              x: o,\n              y: this.canvas.height\n            }\n          });\n        }\n        return this.stars;\n      }\n    }, b = v;\n  });\nvar k,\n  u,\n  f,\n  T = d(() => {\n    C();\n    z();\n    k = {\n      width: 800,\n      height: 600,\n      randomOpacity: !0,\n      showFps: !1,\n      type: \"dot\"\n    }, u = class {\n      constructor(t) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.config = {};\n        this.stars = null;\n        this.canvas = null;\n        this.starTypes = {\n          dot: w,\n          line: b\n        };\n        this.fps = 0;\n        this.repeat = 0;\n        this.lastCalledTime = 0;\n        this.lastGenerated = 0;\n        this.frontCallbacks = [];\n        this.behindCallbacks = [];\n        this.canvas = t instanceof HTMLCanvasElement ? t : document.querySelector(t), this.ctx = this.canvas.getContext(\"2d\"), this.mergeConfig(i), this.frontCallbacks = [], this.behindCallbacks = [], this.init();\n      }\n      static create(t) {\n        let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return new u(t, i);\n      }\n      mergeConfig(t) {\n        let i = c(c({}, k), t);\n        this.config = i;\n      }\n      init() {\n        this.canvas.setAttribute(\"width\", this.config.width), this.canvas.setAttribute(\"height\", this.config.height), this.stars = new this.starTypes[this.config.type](this.canvas, this.config), this.generateStar(), requestAnimationFrame(t => this.render(t));\n      }\n      setBackground() {\n        let t;\n        typeof this.config.backgroundColor == \"string\" ? t = this.config.backgroundColor : typeof this.config.backgroundColor == \"object\" && (t = this.ctx.createLinearGradient(this.canvas.width / 2, 0, this.canvas.width / 2, this.canvas.height), this.config.backgroundColor.forEach((i, r) => {\n          t.addColorStop(r / this.config.backgroundColor.length, i);\n        })), this.ctx.fillStyle = t, this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n      }\n      draw() {\n        this.behindCallbacks.forEach(t => t(this.ctx)), this.stars.draw(), this.frontCallbacks.forEach(t => t(this.ctx)), this.config.showFps && this.drawFps();\n      }\n      update() {\n        this.stars.update();\n      }\n      addToFront(t) {\n        this.frontCallbacks.push(t);\n      }\n      addToBehind(t) {\n        this.behindCallbacks.push(t);\n      }\n      generateStar() {\n        this.stars.generate(this.config.quantity);\n      }\n      drawFps() {\n        this.ctx.fillStyle = \"white\", this.ctx.fillText(`${this.fps} fps`, 10, 10);\n      }\n      render(t) {\n        this.lastCalledTime || (this.lastCalledTime = t);\n        let i = t - this.lastCalledTime;\n        this.fps = Math.round(1e3 / i), this.lastCalledTime = t, this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.setBackground(), this.draw(), this.update(), requestAnimationFrame(r => this.render(r));\n      }\n    }, f = u;\n    f.DefaultConfig = k;\n  });\nvar P = L((J, M) => {\n  T();\n  M.exports = f;\n});\nexport default P();","map":{"version":3,"mappings":"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","names":["randomNumber","min","max","Math","floor","random","randomArr","arr","length","sinDeg","angleDeg","sin","PI","cosDeg","cos","Dot","dot_default","init_dot","init_utils","constructor","canvas","config","quantity","direction","speed","backgroundColor","starColor","starSize","__spreadValues","ctx","getContext","draw","i","stars","star","beginPath","fillStyle","save","globalAlpha","opacity","arc","x","y","size","fill","restore","closePath","update","dx","dy","width","overflowSize","height","splice","startX","newStarLocation","generate","amount","location","newStar","randomSize","randomOpacity","randomSpeed","push","toFixed","Array","isArray","Line","line_default","init_line","type","slope","frequency","spread","directionY","directionX","distanceX","strokeStyle","forEach","createLinearGradient","color","index","addColorStop","moveTo","start","setLineDash","startPoint","lineDashOffset","progress","quadraticCurveTo","curve","end","stroke","map","endX","adjacentWidth","lineDash","filter","StarbackDefaultConfig","_Starback","Starback","init_src","showFps","starTypes","dot","line","fps","repeat","lastCalledTime","lastGenerated","frontCallbacks","behindCallbacks","HTMLCanvasElement","document","querySelector","mergeConfig","init","create","instanceConfig","setAttribute","generateStar","requestAnimationFrame","t","render","setBackground","bg","bgString","fillRect","cb","drawFps","addToFront","addToBehind","fillText","timestamp","deltaTime","round","clearRect","DefaultConfig","module","exports"],"sources":["../src/utils.ts","../src/types/dot.ts","../src/types/line.ts","../src/index.ts","../src/starback.ts"],"sourcesContent":["/**\r\n * Get random number between two given number.\r\n * @param {Number} min Minimum Number\r\n * @param {Number} max Maximum Number\r\n * @returns {Number} The random number result\r\n*/\r\nexport function randomNumber(min, max) {\r\n    return Math.floor(Math.random() * (max - min) + 1) + min\r\n}\r\n\r\nexport function randomArr(arr) {\r\n    return arr[Math.floor(Math.random() * arr.length)]\r\n}\r\n\r\n/**\r\n * Convert angle degree to sin degree\r\n * @param {*} angleDeg \r\n */\r\nexport function sinDeg(angleDeg) {\r\n    return Math.sin(angleDeg * (Math.PI / 180))\r\n}\r\n\r\n/**\r\n * Convert angle degree to cos degree\r\n * @param {*} angleDeg \r\n */\r\nexport function cosDeg(angleDeg) {\r\n    return Math.cos(angleDeg * (Math.PI / 180))\r\n}","import { StarDotConfig, StarType } from \"../types\"\r\nimport { cosDeg, randomArr, randomNumber, sinDeg } from '../utils'\r\n\r\nclass Dot implements StarType {\r\n    /**\r\n     * Collection of stars\r\n     * @param\r\n     */\r\n    stars = []\r\n    type: 'dot'\r\n    config: StarDotConfig = {\r\n        quantity: 100,\r\n        direction: 100,\r\n        speed: [0.5, .8],\r\n        backgroundColor: '#ccc',\r\n        starColor: 'white',\r\n        starSize: [0, 3],\r\n    }\r\n    overflowSize = 10\r\n\r\n\r\n    /** @type {HTMLCanvasElement} */\r\n    canvas = null\r\n\r\n    /** @type {CanvasRenderingContext2D} */\r\n    ctx = null\r\n    \r\n    constructor(canvas, config) {\r\n        this.config = {...this.config, ...config}\r\n        this.canvas = canvas\r\n        this.ctx = canvas.getContext('2d')\r\n        \r\n    }\r\n    draw() {\r\n        \r\n        for(let i = 0; i < this.stars.length; i++) {\r\n            let star = this.stars[i]\r\n            \r\n\r\n            this.ctx.beginPath()\r\n            this.ctx.fillStyle = this.config.starColor\r\n            this.ctx.save()\r\n            this.ctx.globalAlpha = star.opacity\r\n            this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2)\r\n            this.ctx.fill()\r\n            this.ctx.restore()\r\n            this.ctx.closePath()\r\n        }\r\n    }\r\n    update() {\r\n        let dx = sinDeg(this.config.direction) \r\n        let dy = cosDeg(this.config.direction) \r\n        \r\n        for(let i = 0; i < this.stars.length; i++) {\r\n            let star = this.stars[i]\r\n            star.x += dx * star.speed\r\n            star.y += dy * star.speed\r\n\r\n            // When the star location is outside the canvas, replace the star with a new one\r\n            if(star.x > this.canvas.width + this.overflowSize || \r\n                star.x < 0 - this.overflowSize ||\r\n                star.y > this.canvas.height + this.overflowSize ||\r\n                star.y < 0 - this.overflowSize) {\r\n\r\n                    this.stars.splice(i, 1)\r\n                    \r\n                    let x, y, startX\r\n\r\n                    // If the direction is top or bottom\r\n                    if(dy == -1 || dy == 1) {\r\n                        startX = 0\r\n                        x = randomNumber(startX, this.canvas.width)\r\n                        y = dy == 1 ? 0 : this.canvas.height\r\n                    }\r\n                    // If the direction is right or left\r\n                    else if(dx == -1 || dx == 1) {\r\n                        startX = dx == 1 ? 0 : this.canvas.width\r\n                        x = startX + (this.overflowSize * -dx)\r\n                        y = randomNumber(0, this.canvas.height)\r\n                    }\r\n                    // If the direction is bottom-right\r\n                    else if(dx > 0  && dy > 0) {\r\n                        startX = -this.overflowSize\r\n                        x = randomArr([startX, randomNumber(startX, this.canvas.width - this.overflowSize)])\r\n                        y = x == startX ? randomNumber(startX, this.canvas.height - this.overflowSize) : -this.overflowSize\r\n                    } \r\n                    // If the direction is bottom-left\r\n                    else if(dx < 0  && dy > 0) {\r\n                        startX = -this.canvas.width + this.overflowSize\r\n                        x = randomArr ([startX, randomNumber(startX, 0 + this.overflowSize)])\r\n                        y = x == startX ? randomNumber(startX, 0 - this.canvas.height + this.overflowSize) : -this.overflowSize\r\n                    } \r\n                    // If the direction is top-left\r\n                    else if (dx < 0  && dy < 0) {\r\n                        startX = this.canvas.width + this.overflowSize\r\n                        x = randomArr([startX, randomNumber(startX, 0 + this.overflowSize)])\r\n                        y = x == startX ? randomNumber(startX, 0 + this.overflowSize) : this.canvas.height + this.overflowSize\r\n                    }\r\n                    // If the direction is top-right\r\n                    else if (dx > 0  && dy < 0) {\r\n                        startX = -this.overflowSize\r\n                        x = randomArr([startX, randomNumber(startX, this.canvas.width-this.overflowSize)])\r\n                        y = x == startX ? randomNumber(startX, this.canvas.height - this.overflowSize) : this.canvas.height + this.overflowSize\r\n                    }\r\n                    \r\n                    let newStarLocation = {\r\n                        x,\r\n                        y\r\n                    }\r\n                    this.generate(1, newStarLocation)\r\n                }\r\n        }\r\n    }\r\n    generate(amount, location = null) {\r\n        \r\n        // Generate star in specific location\r\n        if(location) {\r\n            let { x, y } = location\r\n            let newStar = {\r\n                x, \r\n                y, \r\n                size: this.randomSize(), \r\n                opacity: this.randomOpacity(),\r\n                speed: this.randomSpeed()\r\n            }\r\n            \r\n            return this.stars.push(newStar)\r\n            \r\n        }\r\n        \r\n        // If no location provided, it will generate stars in random locations.\r\n        for(let i = 0; i < amount; i++) {\r\n            let x = randomNumber(0, this.canvas.width)\r\n            let y = randomNumber(0, this.canvas.height)\r\n            \r\n\r\n            this.stars.push({\r\n                x,\r\n                y,   \r\n                size: this.randomSize(),\r\n                opacity: this.randomOpacity(),\r\n                speed: this.randomSpeed()\r\n            })\r\n        }\r\n\r\n    }\r\n    randomSize() {\r\n        return typeof this.config.starSize == 'object' ? randomNumber(this.config.starSize[0], this.config.starSize[1]) : this.config.starSize\r\n    }\r\n    randomOpacity() {\r\n        let opacity = this.config.randomOpacity\r\n        if(typeof opacity == 'boolean') \r\n            return !opacity ? 1 : (opacity ? Math.random() : 1).toFixed(2)\r\n        else \r\n            return (Math.random() * (opacity[1] - opacity[0]) + opacity[0]).toFixed(2)\r\n    }\r\n    randomSpeed() {\r\n        const speed = this.config.speed\r\n        \r\n        return typeof Array.isArray(speed) ? Math.random() * (speed[1] - speed[0]) + speed[0] : speed\r\n    }\r\n}\r\n\r\nexport default Dot","import { StarLineConfig, StarType } from '../types'\r\nimport {  randomArr, randomNumber } from '../utils'\r\n\r\nclass Line implements StarType {\r\n    /**\r\n     * Collection of stars\r\n     * @param\r\n     */\r\n    stars = []\r\n    config: StarLineConfig = {\r\n      type: 'line',  \r\n      slope: { x: 1, y: 1},\r\n      frequency: 10,\r\n      speed: 2,\r\n      starSize: 100,\r\n      starColor: ['#fb00ff', '#00dde0'],\r\n      spread: 1,\r\n      directionY: -1, // 1 = top-to-bottom, 2 = bottom-to-top\r\n      directionX: 1, // 1 = left-to-right, 2 = right-to-left\r\n      distanceX: 0.1,\r\n      quantity: 200\r\n    }\r\n    direction = 225\r\n\r\n    /** @type {HTMLCanvasElement} */\r\n    canvas = null\r\n\r\n    /** @type {CanvasRenderingContext2D} */\r\n    ctx = null\r\n  \r\n    constructor(canvas, config) {\r\n      this.config = {...this.config, ...config}\r\n      this.canvas = canvas\r\n      this.ctx = canvas.getContext('2d')\r\n    }\r\n    draw() {\r\n        this.ctx.strokeStyle = 'white'\r\n        this.stars.forEach((star) => {\r\n          // draw the stars\r\n          let starColor\r\n          if (Array.isArray(this.config.starColor)) {\r\n              starColor = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height)\r\n              this.config.starColor.forEach((color, index) => starColor.addColorStop(index / this.config.starColor.length, color))\r\n          } else starColor = this.config.starColor\r\n\r\n          // pathway with berzier curve\r\n          this.ctx.save()\r\n          this.ctx.strokeStyle = starColor\r\n          this.ctx.beginPath()\r\n          this.ctx.moveTo(star.start.x, star.start.y)\r\n          this.ctx.setLineDash([this.config.starSize, star.startPoint * this.config.frequency])\r\n          this.ctx.lineDashOffset = this.config.directionY * (star.progress + star.length)\r\n          this.ctx.quadraticCurveTo(star.curve.x, star.curve.y, star.end.x, star.end.y)\r\n          this.ctx.stroke()\r\n          this.ctx.closePath()\r\n          this.ctx.restore()\r\n        \r\n\r\n        })\r\n    }\r\n    update() {\r\n        this.stars.map((star, index) => {\r\n            star.progress += star.speed\r\n            // if(star.y - star.height > this.canvas.height) return stars.splice(index,1)\r\n        })\r\n    }\r\n    \r\n  generate() {\r\n\r\n    for(let i = 0; i < this.config.quantity; i++) {\r\n      const x = randomNumber(-20, this.canvas.width)\r\n      const y = x <= 0 ? randomNumber(0, this.canvas.height) : 0\r\n      const height = 100\r\n      const endX = x + (this.canvas.width * this.config.distanceX + this.config.spread * x * this.config.directionX)\r\n      const adjacentWidth = endX - x\r\n      const length = this.canvas.height\r\n  \r\n      this.stars.push({\r\n        x,\r\n        y,\r\n        length,\r\n        height,\r\n        progress: 0,\r\n        speed: this.config.speed + Math.random() / 5,\r\n        lineDash: randomNumber(50, 100),\r\n        filter: {\r\n          opacity: randomArr([randomNumber(20, 100) + '%', false]),\r\n        },\r\n        start: {\r\n          x,\r\n          y,\r\n        },\r\n        curve: {\r\n          x: x + adjacentWidth * this.config.slope.x,\r\n          y: y + this.canvas.height * this.config.slope.y,\r\n        },\r\n        startPoint: randomNumber(10, 100),\r\n        end: {\r\n          x: endX,\r\n          y: this.canvas.height,\r\n        },\r\n      })\r\n    }\r\n    return this.stars\r\n  }\r\n    \r\n}\r\n\r\nexport default Line","import { StarbackConfig, StarbackInterface, StarType } from \"./types\"\r\nimport Dot from \"./types/dot\"\r\nimport Line from \"./types/line\"\r\n\r\n/**\r\n * Default Config\r\n * @type {Object}\r\n */\r\nconst StarbackDefaultConfig: StarbackConfig = {\r\n  width: 800,\r\n  height: 600,\r\n\r\n  randomOpacity: true,\r\n  showFps: false,\r\n  type: 'dot'\r\n}\r\n\r\n/**\r\n * Starback class wrapper\r\n * @class Starback\r\n */\r\nexport default class Starback implements StarbackInterface {\r\n  static DefaultConfig = StarbackDefaultConfig\r\n\r\n  private ctx\r\n  public config: StarbackConfig = {}\r\n  public stars: StarType = null\r\n  public canvas = null\r\n  public starTypes = {\r\n    'dot': Dot,\r\n    'line': Line\r\n  }\r\n  public fps = 0\r\n  private repeat = 0\r\n\r\n  private lastCalledTime = 0\r\n  private lastGenerated = 0\r\n  private frontCallbacks: Function[] = []\r\n  private behindCallbacks: Function[] = []\r\n\r\n\r\n  /**\r\n   * Starback library\r\n   * @param {HTMLElement|string} Canvas element or the selector\r\n   * @param {Object} options\r\n   */\r\n  constructor(canvas: HTMLCanvasElement | string, config = {}) {\r\n    this.canvas = canvas instanceof HTMLCanvasElement ? canvas : document.querySelector(canvas)\r\n\r\n    this.ctx = this.canvas.getContext('2d')\r\n\r\n    // merge config\r\n    this.mergeConfig(config)\r\n\r\n    // storing callbacks\r\n    this.frontCallbacks = []\r\n    this.behindCallbacks = []\r\n\r\n\r\n    this.init()\r\n  }\r\n\r\n  static create(canvas: HTMLCanvasElement | string, config: StarbackConfig = {}) {\r\n    return new Starback(canvas, config)\r\n  }\r\n\r\n  /**\r\n   * Merge Config\r\n   * @param  {StarbackDefaultConfig|object} instanceConfig\r\n   */\r\n  private mergeConfig(instanceConfig) {\r\n    // merge config\r\n    let config = { ...StarbackDefaultConfig, ...instanceConfig }\r\n\r\n    // apply config\r\n    this.config = config\r\n  }\r\n\r\n  /**\r\n   * Initialize canvas before render\r\n   */\r\n  private init() {\r\n    this.canvas.setAttribute('width', this.config.width)\r\n    this.canvas.setAttribute('height', this.config.height)\r\n    this.stars = new this.starTypes[this.config.type](this.canvas, this.config)\r\n\r\n    this.generateStar()\r\n\r\n    requestAnimationFrame((t) => this.render(t))\r\n  }\r\n\r\n\r\n  /**\r\n   * Set background for the whole canvas\r\n   */\r\n  private setBackground() {\r\n    let bg\r\n\r\n    if (typeof this.config.backgroundColor == 'string') bg = this.config.backgroundColor\r\n    else if (typeof this.config.backgroundColor == 'object') {\r\n      bg = this.ctx.createLinearGradient(this.canvas.width / 2, 0, this.canvas.width / 2, this.canvas.height)\r\n\r\n      this.config.backgroundColor.forEach((bgString, index) => {\r\n        bg.addColorStop(index / this.config.backgroundColor.length, bgString)\r\n      })\r\n    }\r\n    this.ctx.fillStyle = bg\r\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)\r\n  }\r\n\r\n  /**\r\n   * Draw the frame into the canvas\r\n   */\r\n  private draw() {\r\n    this.behindCallbacks.forEach(cb => cb(this.ctx))\r\n    this.stars.draw()\r\n    this.frontCallbacks.forEach(cb => cb(this.ctx))\r\n\r\n    // Show FPS if config.showFps is enabled\r\n    if (this.config.showFps) this.drawFps()\r\n  }\r\n\r\n  /**\r\n   * Update everything in the canvas frame including stars\r\n   */\r\n  private update() {\r\n    this.stars.update()\r\n  }\r\n\r\n  /**\r\n   * Add an object in front of the stars\r\n   * @param {Function} cb Callback function\r\n   */\r\n  addToFront(cb) {\r\n    this.frontCallbacks.push(cb)\r\n  }\r\n\r\n  /**\r\n   * Add an object behind the stars\r\n   * @param {Function} cb Callback function\r\n   */\r\n  addToBehind(cb) {\r\n    this.behindCallbacks.push(cb)\r\n  }\r\n\r\n  /**\r\n   * The total quantity of stars in canvas\r\n   * @param {Number} amount The number of stars\r\n   */\r\n  generateStar() {\r\n    this.stars.generate(this.config.quantity)\r\n  }\r\n\r\n  /**\r\n   * Draw the FPS in the canvas.\r\n   */\r\n  private drawFps() {\r\n    this.ctx.fillStyle = 'white'\r\n    this.ctx.fillText(`${this.fps} fps`, 10, 10)\r\n  }\r\n\r\n\r\n  /**\r\n   * Canvas render function\r\n   * @param {DOMHighResTimeStamp} timestamp \r\n   */\r\n  private render(timestamp) {\r\n    if (!this.lastCalledTime) this.lastCalledTime = timestamp\r\n\r\n    let deltaTime = timestamp - this.lastCalledTime\r\n    this.fps = Math.round(1000 / deltaTime)\r\n    this.lastCalledTime = timestamp\r\n\r\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\r\n    this.setBackground()\r\n    this.draw()\r\n    this.update()\r\n\r\n    requestAnimationFrame((t) => this.render(t))\r\n  }\r\n\r\n\r\n}\r\n","import Starback from './index'\r\nmodule.exports = Starback"]},"metadata":{},"sourceType":"module"}